/* eslint-disable no-restricted-syntax */
/* eslint-disable no-labels */
/* eslint-disable no-await-in-loop */
import console from 'electron-log';
import { nanoid } from 'nanoid';
import { Image, createCanvas, Canvas } from '@napi-rs/canvas';

import {
  RectWh,
  RectXywhf,
  FinderInput,
  FlippingOption,
  CallbackResult,
  findBestPacking,
} from '@recative/atlas';
import {
  hashObject,
  PreloadLevel,
  IResourceItem,
  imageCategoryTag,
  BidirectionalMap,
  getHighestPreloadLevel,
  REDIRECT_URL_EXTENSION_ID,
  frameSequenceGroupResourceTag,
  IDetailedResourceItemForClient,
} from '@recative/definitions';
import {
  ResourceProcessor,
  TerminalMessageLevel as Level,
} from '@recative/extension-sdk';

import type {
  IResourceFile,
  IResourceGroup,
  IResourceItemForClient,
} from '@recative/definitions';
import type {
  IBundleGroup,
  PostProcessedResourceItemForImport,
  PostProcessedResourceItemForUpload,
  IPostProcessedResourceFileForUpload,
  IPostProcessedResourceFileForImport,
} from '@recative/extension-sdk';

import { TextureAnalysisProcessor } from './TextureAnalysisProcessor';

export interface AtlasResourceProcessorConfig {
  enable: string;
}

// For compatibility concern, we need to hardcode this value.
const ATLAS_MAX_DIMENSION_SIZE = 2048;
const REQUIRED_VALID_AREA_RATIO = 0.6;
const IDEAL_VALID_AREA_RATIO = 0.8;

const ATLAS_PADDING = 2;

const ATLAS_REDIRECT_REASON = 'atlas';

export const PARSE_RESOURCE_FILE_TO_BE_REFACTORED_TO_DEFINITIONS = <
  T extends
    | PostProcessedResourceItemForImport
    | IResourceItem
    | IResourceItemForClient
>(
  x: T,
  resources: T[]
): T => {
  if ('redirectTo' in x && x.redirectTo) {
    const resource = resources.find((y) => y.id === x.redirectTo);
    if (!resource) {
      throw new TypeError(`Redirected to resource not found`);
    }

    return PARSE_RESOURCE_FILE_TO_BE_REFACTORED_TO_DEFINITIONS(
      resource,
      resources
    );
  }

  return x;
};

export class AtlasResourceProcessor extends ResourceProcessor<
  keyof AtlasResourceProcessorConfig
> {
  static id = '@recative/extension-rs-atlas/AtlasResourceProcessor';

  static label = 'Atlas';

  static resourceConfigUiFields = [
    {
      id: 'enabled',
      type: 'boolean',
      label: 'Add texture to atlas pack',
      title: 'Enable',
    },
    {
      id: 'grouping',
      type: 'string',
      label: 'Grouping',
      required: false,
    },
  ] as const;

  static nonMergeableResourceExtensionConfiguration = [
    `${AtlasResourceProcessor.id}~~x`,
    `${AtlasResourceProcessor.id}~~y`,
    `${AtlasResourceProcessor.id}~~w`,
    `${AtlasResourceProcessor.id}~~h`,
    `${AtlasResourceProcessor.id}~~f`,
    `${AtlasResourceProcessor.id}~~includes`,
    `${AtlasResourceProcessor.id}~~dict`,
    `${AtlasResourceProcessor.id}~~frame`,
    `${AtlasResourceProcessor.id}~~frames`,
  ];

  protected configValidator(
    x: unknown
  ): x is Record<keyof AtlasResourceProcessorConfig, string> {
    return !!x || true;
  }

  private getImageSize = (resource: IPostProcessedResourceFileForUpload) => {
    const w = Number.parseInt(
      resource.extensionConfigurations[`${TextureAnalysisProcessor.id}~~tw`],
      10
    );
    const h = Number.parseInt(
      resource.extensionConfigurations[`${TextureAnalysisProcessor.id}~~th`],
      10
    );

    if (Number.isNaN(w) || Number.isNaN(h)) {
      throw new TypeError(
        `Image size is not correctly generated by the analysis processor, this is a bug: ${resource.label}(${resource.id})`
      );
    }

    return new RectWh(w, h);
  };

  private getImageEnvelope = (
    resource: IPostProcessedResourceFileForUpload
  ) => {
    const x = Number.parseInt(
      resource.extensionConfigurations[`${TextureAnalysisProcessor.id}~~ex`],
      10
    );
    const y = Number.parseInt(
      resource.extensionConfigurations[`${TextureAnalysisProcessor.id}~~ey`],
      10
    );
    const w = Number.parseInt(
      resource.extensionConfigurations[`${TextureAnalysisProcessor.id}~~ew`],
      10
    );
    const h = Number.parseInt(
      resource.extensionConfigurations[`${TextureAnalysisProcessor.id}~~eh`],
      10
    );

    if (
      Number.isNaN(x) ||
      Number.isNaN(y) ||
      Number.isNaN(w) ||
      Number.isNaN(h)
    ) {
      throw new TypeError(
        `Envelope is not correctly generated by the analysis processor, this is a bug`
      );
    }

    return new RectXywhf(x, y, w, h);
  };

  private generateAtlasImage = async (
    spaceRect: RectWh,
    currentTasks: RectXywhf[],
    resourceToTaskMap: BidirectionalMap<
      IPostProcessedResourceFileForUpload,
      RectXywhf
    >,
    resourceToEnvelopeMap: BidirectionalMap<
      IPostProcessedResourceFileForUpload,
      RectXywhf
    >,
    onPacked: () => void
  ) => {
    const canvas = createCanvas(
      2 ** Math.ceil(Math.log2(spaceRect.w)),
      2 ** Math.ceil(Math.log2(spaceRect.h))
    );
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      throw new Error('Canvas context is null!');
    }

    for (let i = 0; i < currentTasks.length; i += 1) {
      onPacked();
      const currentTask = currentTasks[i];
      const rectResource = resourceToTaskMap.get(currentTask);
      if (!rectResource) {
        throw new TypeError(
          'Resource ID not available in the map, this is a bug!'
        );
      }

      const envelopeRect = resourceToEnvelopeMap.get(rectResource);
      if (!envelopeRect) {
        throw new TypeError(
          'Envelope not available in the map, this is a bug!'
        );
      }

      const subImage = new Image();
      subImage.src = await this.getResourceBuffer(rectResource);

      const ew = envelopeRect.w + 2 * ATLAS_PADDING;
      const eh = envelopeRect.h + 2 * ATLAS_PADDING;

      const notFlipped = currentTask.w === ew && currentTask.h === eh;
      const flipped = currentTask.w === eh && currentTask.h === ew;
      if (notFlipped) {
        // Draw directly
        ctx.drawImage(
          subImage,
          envelopeRect.x,
          envelopeRect.y,
          envelopeRect.w,
          envelopeRect.h,
          currentTask.x + ATLAS_PADDING,
          currentTask.y + ATLAS_PADDING,
          envelopeRect.w,
          envelopeRect.h
        );
      } else if (flipped) {
        // Draw rotated
        ctx.save();
        ctx.translate(currentTask.x + currentTask.w, currentTask.y);
        ctx.rotate(Math.PI / 2);
        ctx.drawImage(
          subImage,
          envelopeRect.x,
          envelopeRect.y,
          envelopeRect.w,
          envelopeRect.h,
          ATLAS_PADDING,
          ATLAS_PADDING,
          envelopeRect.w,
          envelopeRect.h
        );
        ctx.restore();
      } else {
        throw new TypeError(
          `Wrong image size: Atlas (${envelopeRect.w} x ${envelopeRect.h}), Envelope (${currentTask.w} x ${currentTask.h})`
        );
      }
    }

    const outputBuffer = await canvas.encode('png');

    return { canvas, outputBuffer };
  };

  private cleanupResourceUrl = (
    resources: IPostProcessedResourceFileForUpload[]
  ) => {
    // Cleanup all redirect URLs, since we will generate new ones for each of them
    resources.forEach((x) => {
      if (
        x.url[REDIRECT_URL_EXTENSION_ID] &&
        x.url[REDIRECT_URL_EXTENSION_ID].endsWith(ATLAS_REDIRECT_REASON)
      ) {
        delete x.url[REDIRECT_URL_EXTENSION_ID];
        this.dependency.updateResourceDefinition(x);
      }
    });
  };

  /**
   * Split files into different based on grouping rules, current rule is
   * hard-coded, based on language of the resource, could support more options
   * via plugin configurations in the future (possible...).
   */
  private buildBundleGroupToFileSetMap = (
    resources: IPostProcessedResourceFileForUpload[],
    bundleGroups: IBundleGroup[]
  ) => {
    const bundleGroupToFileSetMap = new Map<
      IBundleGroup & { atlasGrouping: string },
      IPostProcessedResourceFileForUpload[]
    >();

    // Dispatch all texture resources to different groups
    const filteredResources = resources.filter((x) => {
      return (
        x.extensionConfigurations[`${AtlasResourceProcessor.id}~~enabled`] ===
          'yes' &&
        x.mimeType.startsWith('image') &&
        !x.tags.includes('custom:frame-sequence-pointer!') &&
        !x.tags.includes('custom:merged-atlas!')
      );
    });

    ResourceProcessor.mapBundleGroup(
      filteredResources,
      bundleGroups,
      (resourceGroup, groupDefinition) => {
        const resourceByAtlasGrouping: Map<
          string,
          IPostProcessedResourceFileForUpload[]
        > = new Map();

        resourceGroup.forEach((resource) => {
          const internalGroupingDefinition = {
            ...groupDefinition,
            atlasGrouping:
              resource.extensionConfigurations[
                `${AtlasResourceProcessor.id}~~grouping`
              ] || 'default',
          };

          const groupDefinitionStr = JSON.stringify(internalGroupingDefinition);

          if (!resourceByAtlasGrouping.has(groupDefinitionStr)) {
            resourceByAtlasGrouping.set(groupDefinitionStr, []);
          }

          resourceByAtlasGrouping.get(groupDefinitionStr)?.push(resource);
        });

        resourceByAtlasGrouping.forEach(
          (resourcesFiles, groupDefinitionStr) => {
            const newGroup = JSON.parse(groupDefinitionStr) as IBundleGroup & {
              atlasGrouping: string;
            };
            bundleGroupToFileSetMap.set(newGroup, resourcesFiles);
          }
        );
      },
      true
    );

    const groupDefinitions = [...bundleGroupToFileSetMap.keys()];

    // #region Task Summary
    const emptyGroupCount = groupDefinitions.filter((groupKey) => {
      return !bundleGroupToFileSetMap.get(groupKey)?.length;
    }).length;

    this.dependency.logToTerminal(':: :: Atlas Task Summary:', Level.Info);
    this.dependency.logToTerminal(
      `:: :: :: Files: ${filteredResources.length} marked / ${resources.length} in total`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: Total Groups: ${bundleGroupToFileSetMap.size}`,
      Level.Info
    );
    if (emptyGroupCount) {
      this.dependency.logToTerminal(
        `:: :: :: Empty Groups: ${emptyGroupCount}`,
        Level.Warning
      );
    }
    // #endregion

    return bundleGroupToFileSetMap;
  };

  /**
   * We build a map of all the resources that are going to be packed into the
   * atlas, this is used to get the size of the atlas.
   * @param bundleGroupToFileSetMap A map of bundle group to resource files.
   */
  private queryImageSize = async (
    bundleGroupToFileSetMap: Map<
      IBundleGroup,
      IPostProcessedResourceFileForUpload[]
    >
  ) => {
    let totalInputSize = 0;
    let totalInputCount = 0;

    const groupDefinitions = [...bundleGroupToFileSetMap.keys()];

    const resourceToRawRectMap = new BidirectionalMap<
      IPostProcessedResourceFileForUpload,
      RectXywhf
    >();
    const resourceToEnvelopeMap = new BidirectionalMap<
      IPostProcessedResourceFileForUpload,
      RectXywhf
    >();

    // Build a index of the size of all images.
    const imageSizeQueryForEachGroupTask = await Promise.allSettled(
      groupDefinitions.map(async (groupKey, groupIndex) => {
        const resourceFiles = bundleGroupToFileSetMap.get(groupKey);

        // #region Resource Checkup
        if (!resourceFiles) {
          throw new TypeError(
            'Group value not found based on the key, this is a bug!'
          );
        }
        // #endregion

        const imageSizeQueryResult = await Promise.allSettled(
          resourceFiles.map(async (resource) => {
            const imageSize = this.getImageSize(resource);

            resourceToRawRectMap.set(
              resource,
              new RectXywhf(0, 0, imageSize.w, imageSize.h)
            );
            totalInputCount += 1;
            totalInputSize += imageSize.area();
            const imageEnvelope = this.getImageEnvelope(resource);

            // The image is too large to be packed, will skip.
            if (
              imageEnvelope.w > ATLAS_MAX_DIMENSION_SIZE ||
              imageEnvelope.h > ATLAS_MAX_DIMENSION_SIZE
            ) {
              this.dependency.logToTerminal(
                `:: :: [Group ${groupIndex}] ${resource.label} is too large, will skip`,
                Level.Info
              );

              return;
            }

            resourceToEnvelopeMap.set(resource, imageEnvelope);
          })
        );

        // #region Failed Image Size Query Report
        const failedMediaQueryTask = imageSizeQueryResult.filter(
          (x) => x.status === 'rejected'
        );

        if (failedMediaQueryTask.length) {
          this.dependency.logToTerminal(
            `:: :: [Group ${groupIndex}] ${failedMediaQueryTask.length} image size query tasks failed.`,
            Level.Error
          );

          failedMediaQueryTask.forEach((task) => {
            if (task.status === 'rejected') {
              this.dependency.logToTerminal(
                `:: :: :: ${task.reason}`,
                Level.Error
              );
            }
          });

          throw new Error(`Image size query task failed.`);
        }
        // #endregion
      })
    );

    // #region Failed Image Size Query For Each Group Task Report
    const failedAtlasBoundingTasks = imageSizeQueryForEachGroupTask.filter(
      (x) => x.status === 'rejected'
    );

    if (failedAtlasBoundingTasks.length) {
      this.dependency.logToTerminal(
        `:: :: ${failedAtlasBoundingTasks.length} bounding tasks failed`,
        Level.Error
      );

      this.reportFailedTaskToConsole(failedAtlasBoundingTasks);
      throw new Error('Atlas task failed while calculating bounding box');
    }
    // #endregion

    return {
      resourceToRawRectMap,
      resourceToEnvelopeMap,
      totalInputCount,
      totalInputSize,
    };
  };

  /**
   * This method will build a map of resource to the packed image rect.
   */
  private getInitialAtlasBoundingBox = (
    filesInGroup: IPostProcessedResourceFileForUpload[],
    resourceToEnvelopeMap: BidirectionalMap<
      IPostProcessedResourceFileForUpload,
      RectXywhf
    >
  ) => {
    const resourceToTaskMap = new BidirectionalMap<
      IPostProcessedResourceFileForUpload,
      RectXywhf
    >();

    const initialTasks = filesInGroup
      .map((resource) => {
        const envelope = resourceToEnvelopeMap.get(resource);

        if (!envelope) {
          throw new TypeError(
            `ResourceToEnvelopeMap don't have the envelope (id: ${resource.id}, label: ${resource.label}), it is a bug!`
          );
        }

        const task = new RectXywhf(
          envelope.x,
          envelope.y,
          envelope.w + ATLAS_PADDING * 2,
          envelope.h + ATLAS_PADDING * 2
        );
        resourceToTaskMap.set(resource, task);

        return task;
      })
      .sort((a, b) => a.area() - b.area());

    return { initialTasks, resourceToTaskMap };
  };

  private reportAtlasGroupResult = (
    currentTask: RectXywhf[],
    nextTask: RectXywhf[],
    groupIndex: number,
    groupKey: IBundleGroup,
    filesInGroupCount: number,
    packedFiles: number,
    skippedFiles: number
  ) => {
    const ceased = currentTask.length === 0 && nextTask.length === 0;
    const level = ceased ? Level.Warning : Level.Info;

    this.dependency.logToTerminal(
      `:: :: [Group ${groupIndex}] Group report:`,
      level
    );

    this.dependency.logToTerminal(`:: :: :: Selector:`, level);

    Object.entries(groupKey).forEach(([key, value]) => {
      if (typeof value === 'undefined') {
        this.dependency.logToTerminal(`:: :: :: :: ${key}: [ANY]`, level);
      } else if (typeof value === 'string') {
        this.dependency.logToTerminal(`:: :: :: :: ${key}: "${value}"`, level);
      } else {
        this.dependency.logToTerminal(
          `:: :: :: :: ${key}: ${value.length ? value.join(', ') : '[EMPTY]'}`,
          level
        );
      }
    });

    this.dependency.logToTerminal(
      `:: :: :: Total: ${filesInGroupCount} files`,
      level
    );

    if (!ceased) {
      this.dependency.logToTerminal(
        `:: :: :: Packed: ${packedFiles} files`,
        level
      );
    }

    this.dependency.logToTerminal(
      `:: :: :: Skipped: ${skippedFiles} files`,
      level
    );

    if (ceased) {
      this.dependency.logToTerminal(`:: :: :: All files skipped`, level);
    }

    return true;
  };

  private reportAtlasImageResult = (
    resourceDescription: IPostProcessedResourceFileForUpload,
    spaceRect: RectWh,
    canvas: Canvas,
    outputBuffer: Buffer,
    currentTask: RectXywhf[],
    nextTask: RectXywhf[],
    groupIndex: number,
    skippedFiles: number
  ) => {
    // #region Atlas Report
    this.dependency.logToTerminal(
      `:: :: [Group ${groupIndex}] Atlas result:`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: Space size: ${spaceRect.w} x ${spaceRect.h}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: Canvas size: ${canvas.width} x ${canvas.height}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: Resource#: ${resourceDescription.id}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: File Name: ${this.getOutputFileName(resourceDescription, {})}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: File size: ${outputBuffer.byteLength} bytes`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: Task Detail: ${currentTask.length} packed, ${nextTask.length} remains, ${skippedFiles} skipped`,
      Level.Info
    );
    // #endregion
  };

  async beforePublishMediaBundle(
    resources: IPostProcessedResourceFileForUpload[],
    mediaBuildId: number,
    bundleGroups: IBundleGroup[]
  ) {
    let packedInputSize = 0;
    let totalOutputSize = 0;
    let packedInputCount = 0;
    let totalOutputCount = 0;
    let totalSkippedCount = 0;

    this.cleanupResourceUrl(resources);
    const bundleGroupToFileSetMap = this.buildBundleGroupToFileSetMap(
      resources,
      bundleGroups
    );
    const {
      resourceToRawRectMap,
      resourceToEnvelopeMap,
      totalInputCount,
      totalInputSize,
    } = await this.queryImageSize(bundleGroupToFileSetMap);

    const groupDefinitions = [...bundleGroupToFileSetMap.keys()];

    // Calculating pack for each group of file now.
    const imageGenerationTasks = await Promise.allSettled(
      groupDefinitions.map(async (groupKey, groupIndex) => {
        const filesInGroup = bundleGroupToFileSetMap.get(groupKey);

        // #region Group Initialization and Empty Checkup
        if (!filesInGroup) {
          throw new TypeError(
            'Group value not found based on the key, this is a bug!'
          );
        }

        if (!filesInGroup.length) return;
        // #endregion

        let taskSuccess: boolean | null = null;
        // #region Report Atlas Status Callback
        const reportSuccessful = () => {
          taskSuccess = true;
          return CallbackResult.CONTINUE_PACKING;
        };
        const reportUnsuccessful = () => {
          taskSuccess = false;
          return CallbackResult.ABORT_PACKING;
        };
        // #endregion

        /**
         * Step 1: Let's try to generate the atlas, the task will fail if there's
         * no enough space for all images. If the task failed, we should remove
         * the largest image, and run the task again, to test if the resting
         * images could be packed successfully.
         */
        const initialAtlasAssets = this.getInitialAtlasBoundingBox(
          filesInGroup,
          resourceToEnvelopeMap
        );

        const { resourceToTaskMap } = initialAtlasAssets;

        let currentTask = initialAtlasAssets.initialTasks;
        let nextTask = [] as typeof currentTask;
        let packedFiles = 0;
        let skippedFiles = 0;

        const nextTaskIteration = async (
          reason: string,
          sizeLimit?: number
        ): Promise<boolean> => {
          if (nextTask.length === 1) {
            skippedFiles += 1;
            totalSkippedCount += 1;
            return true;
          }

          currentTask = nextTask;
          nextTask = [];

          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          return wrappedTaskIteration(reason, sizeLimit);
        };

        const wrappedTaskIteration = (
          _reason: string,
          sizeLimit = ATLAS_MAX_DIMENSION_SIZE,
          stopTryingShrinkSpace = false
        ) => {
          return new Promise<boolean>((resolve, reject) => {
            globalThis.setTimeout(() => {
              // eslint-disable-next-line @typescript-eslint/no-use-before-define
              taskIteration(_reason, sizeLimit, stopTryingShrinkSpace)
                .then(resolve)
                .catch(reject);
            }, 0);
          });
        };

        const taskIteration = async (
          _reason: string,
          sizeLimit = ATLAS_MAX_DIMENSION_SIZE,
          stopTryingShrinkSpace = false
        ): Promise<boolean> => {
          // this.dependency.logToTerminal(
          //   `:: :: [Group ${groupIndex}] It: ${_reason}`,
          //   Level.Info
          // );
          if (currentTask.length === 0 && nextTask.length === 0) {
            this.reportAtlasGroupResult(
              currentTask,
              nextTask,
              groupIndex,
              groupKey,
              filesInGroup.length,
              packedFiles,
              skippedFiles
            );

            return true;
          }

          currentTask.forEach((task) => {
            task.x = 0;
            task.y = 0;
          });

          const resourceId = nanoid();
          taskSuccess = null;

          let spaceRect: RectWh;
          try {
            spaceRect = findBestPacking(
              currentTask,
              new FinderInput(
                sizeLimit,
                -4,
                reportSuccessful,
                reportUnsuccessful,
                // Flipping is enabled by default, this could be a plugin option if
                // we found any use case, but not for now.
                FlippingOption.ENABLED
              )
            );
          } catch (e) {
            this.dependency.logToTerminal(
              `:: :: :: [Group ${groupIndex}] Atlas generation failed`,
              Level.Error
            );
            if (e instanceof Error) {
              this.dependency.logToTerminal(
                `:: :: :: [Group ${groupIndex}] ${e.stack}`,
                Level.Error
              );
            }

            currentTask.forEach((x) => {
              this.dependency.logToTerminal(
                `:: :: :: :: (${x.x}, ${x.y}) ${x.w} x ${x.h}`,
                Level.Error
              );
            });

            throw e;
          }

          const canvasRect = new RectXywhf(
            0,
            0,
            2 ** Math.ceil(Math.log2(spaceRect.w)),
            2 ** Math.ceil(Math.log2(spaceRect.h))
          );

          if (
            !taskSuccess ||
            spaceRect.w > sizeLimit ||
            spaceRect.h > sizeLimit
          ) {
            const lastTask = currentTask.pop();

            if (lastTask) {
              nextTask.unshift(lastTask);
            }

            // Task not success, try to start next iteration.
            return wrappedTaskIteration(
              'AtlasPackReportFailed',
              sizeLimit < ATLAS_MAX_DIMENSION_SIZE ? sizeLimit * 2 : sizeLimit,
              true
            );
          }

          const currentResources = currentTask.map((task) => {
            const result = resourceToTaskMap.get(task);

            if (!result) {
              throw new TypeError(
                `ResourceToTaskMap don't have the task, it is a bug!`
              );
            }

            return result;
          });

          const allDimensions = currentTask.flatMap((x) => [x.w, x.h]);
          const nextSize = sizeLimit / 2;
          const spaceUsageRatio = spaceRect.area() / canvasRect.area();
          const meetIdealCondition = spaceUsageRatio > IDEAL_VALID_AREA_RATIO;
          const meetRequiredCondition =
            spaceUsageRatio > REQUIRED_VALID_AREA_RATIO;

          const ΣTextureSize = currentResources
            .map((resource) => {
              const texture = resourceToRawRectMap.get(resource);

              if (!texture) {
                throw new TypeError(
                  `ResourceToTextureMap don't have the texture, it is a bug!`
                );
              }

              return texture.area();
            })
            .reduce((a, b) => a + b, 0);
          const wasteSpace = ΣTextureSize < canvasRect.area();

          const validPack =
            meetIdealCondition || (meetRequiredCondition && !wasteSpace);
          if (
            // We are not wasting spaces.
            validPack &&
            // We indeed need to pack textures, since there're more than 1
            // texture.
            currentTask.length > 1 &&
            // If the dimensions of the image is larger than the next size, we
            // should not continue packing.
            Math.max(...allDimensions) <= nextSize &&
            // Atlas packing failed since the space is indeed too small, we
            // should not try to shrink the image and accept the sad truth.
            !stopTryingShrinkSpace
          ) {
            if (nextSize < 1) {
              throw new Error(
                `Can't pack the images, the size limit is too small, it is a bug!`
              );
            }

            return wrappedTaskIteration('PackCouldBeSmaller', nextSize);
          }

          /**
           * Step 2: Let's read the atlas result, if there's only one image in
           * the atlas pack result, it means this file can not get any benefit
           * from data packing, we should try to add it into next iteration, and
           * repack all textures.
           * If there're no image available for currentTask, it means we should
           * stop packing.
           */
          if (currentTask.length === 0) {
            if (nextTask.length > 0) {
              this.dependency.logToTerminal(
                `:: :: [Group ${groupIndex}] ${nextTask.length} resources can not be handled anymore`,
                Level.Error
              );
            }

            return false;
          }

          /**
           * Step 3: The task has finished successfully, we need to generate the
           * resource description and a task hash, this hash is used for compare
           * with previous generated post processed resources, if resource with
           * same record found, we don't need to generate a new image, just
           * reuse the old one is enough.
           */
          const preloadTriggers = currentResources.flatMap((x) => {
            return x.type !== 'file' ? [] : x.preloadTriggers;
          });

          const textureRecords = currentTask.map((x) => ({
            id: resourceToTaskMap.get(x)?.id,
            dimension: {
              w: x.w,
              h: x.h,
            },
          }));

          const episodeIds = [
            ...(groupKey.episodeContains || []),
            ...(groupKey.episodeIs || []),
          ];

          const dict: Record<string, RectXywhf> = {};

          currentResources.forEach((x) => {
            const task = resourceToTaskMap.get(x);

            if (!task) {
              throw new TypeError(
                `ResourceToTaskMap don't have the task, it is a bug!`
              );
            }
            dict[x.id] = task;
          });

          const resourceDescription: IPostProcessedResourceFileForUpload = {
            type: 'file',
            id: resourceId,
            fileName: '',
            label: `Recative Atlas Post Processed ${resourceId}`,
            postProcessRecord: {
              mediaBundleId: [mediaBuildId],
              operations: [
                {
                  extensionId: AtlasResourceProcessor.id,
                  // The hash of the atlas task is based on the resource id of
                  // images to be packed. We hope this value is stable enough.
                  postProcessHash: hashObject({
                    textures: textureRecords,
                    groupKey,
                  }),
                },
              ],
            },
            mimeType: 'image/png',
            originalHash: 'unknown',
            convertedHash: { xxHash: 'unknown', md5: 'unknown' },
            managedBy: null,
            url: {},
            cacheToHardDisk: currentResources.some((x) => x.cacheToHardDisk),
            preloadLevel: getHighestPreloadLevel(
              currentResources.map((x) => x.preloadLevel)
            ),
            preloadTriggers,
            episodeIds,
            thumbnailSrc: null,
            duration: null,
            importTime: Date.now(),
            removed: false,
            removedTime: -1,
            resourceGroupId: '',
            tags: [
              ...(groupKey.tagContains ?? []),
              imageCategoryTag.id,
              'custom:merged-atlas!',
            ],
            extensionConfigurations: {
              [`${AtlasResourceProcessor.id}~~includes`]: currentResources
                .map((x) => x.id)
                .join(','),
            },
          };

          this.addPostProcessRecordToPostprocessResource(
            resourceDescription,
            currentTask,
            mediaBuildId
          );

          // We test if the resource is already generated on previous builds, if
          // generated, we simply copy the config but don't run the file
          // generation task, or we have to build the media.
          const matchedProcessRecord = await this.findPostprocessRecord(
            resources,
            resourceDescription.postProcessRecord
          );

          this.dependency.logToTerminal(
            ` :: :: [Group ${groupIndex}] ${
              matchedProcessRecord
                ? '✔ Cache available'
                : '🐌 Will generate cache'
            }`,
            Level.Info
          );

          if (!matchedProcessRecord) {
            // If the file is not cached, generate the atlas image
            const { canvas, outputBuffer } = await this.generateAtlasImage(
              spaceRect,
              currentTask,
              resourceToTaskMap,
              resourceToEnvelopeMap,
              () => {
                packedFiles += 1;
              }
            );

            // #region Hash Result
            const xxHash = await this.dependency.xxHash(outputBuffer);
            const md5 = await this.dependency.md5Hash(outputBuffer);
            // @ts-ignore: We need to force write this.
            resourceDescription.originalHash = xxHash;
            // @ts-ignore: Ditto.
            resourceDescription.convertedHash.xxHash = xxHash;
            // @ts-ignore: Ditto.
            resourceDescription.convertedHash.md5 = md5;
            // #endregion

            Object.values(dict).forEach((task) => {
              const resource = resourceToTaskMap.get(task);
              if (!resource) {
                throw new TypeError(
                  `ResourceToTaskMap don't have the task, it is a bug!`
                );
              }

              const envelope = resourceToEnvelopeMap.get(resource);
              if (!envelope) {
                throw new TypeError(
                  `ResourceToEnvelopeMap don't have the envelope, it is a bug!`
                );
              }

              const pEnvelope = {
                w: envelope.w + 2 * ATLAS_PADDING,
                h: envelope.h + 2 * ATLAS_PADDING,
              };

              const notFlipped =
                task.w === pEnvelope.w && task.h === pEnvelope.h;
              const flipped = task.w === pEnvelope.h && task.h === pEnvelope.w;

              if (!notFlipped && !flipped) {
                throw new Error(
                  `The envelope is not the same size as the task, it is a bug!`
                );
              }

              task.flipped = !notFlipped;
            });
            resourceDescription.extensionConfigurations[
              `${AtlasResourceProcessor.id}~~dict`
            ] = JSON.stringify(dict);

            resources.push(resourceDescription);
            await this.writeOutputFile(
              resourceDescription,
              await canvas.encode('png'),
              {}
            );

            currentTask.forEach((taskRect) => {
              const resource = resourceToTaskMap.get(taskRect);

              if (!resource) {
                throw new TypeError(
                  `ResourceToTaskMap don't have the task, it is a bug!`
                );
              }

              this.dependency.updateResourceDefinition(resource);
            });

            this.reportAtlasImageResult(
              resourceDescription,
              spaceRect,
              canvas,
              outputBuffer,
              currentTask,
              nextTask,
              groupIndex,
              skippedFiles
            );

            packedInputSize += ΣTextureSize;
            totalOutputSize += canvas.width * canvas.height;
            totalOutputCount += 1;
            packedInputCount += currentTask.length;
          } else {
            // the file is already generated, just push the media build id to
            // the post process record.
            matchedProcessRecord.postProcessRecord.mediaBundleId = [
              ...matchedProcessRecord.postProcessRecord.mediaBundleId,
              mediaBuildId,
            ];
          }

          currentTask.forEach((taskRect) => {
            const resource = resourceToTaskMap.get(taskRect);

            if (!resource) {
              throw new TypeError(
                `ResourceToTaskMap don't have the task, it is a bug!`
              );
            }

            this.dependency.updateResourceDefinition(resource);
          });

          if (nextTask.length > 0) {
            return nextTaskIteration('HasUnpackedTasks');
          }

          return this.reportAtlasGroupResult(
            currentTask,
            nextTask,
            groupIndex,
            groupKey,
            filesInGroup.length,
            packedFiles,
            skippedFiles
          );
        };

        await wrappedTaskIteration('Initialized');
      })
    );

    // #region Report Image Gen
    const failedImageGenerationTasks = imageGenerationTasks.filter(
      (x) => x.status === 'rejected'
    );

    if (failedImageGenerationTasks.length) {
      this.dependency.logToTerminal(
        `:: :: ${imageGenerationTasks.length} image generation tasks failed`,
        Level.Error
      );

      this.reportFailedTaskToConsole(imageGenerationTasks);
      throw new Error('Atlas task failed while generating the image');
    }

    this.dependency.logToTerminal(`:: :: Atlas Task Final Report:`, Level.Info);
    this.dependency.logToTerminal(`:: :: :: Files:`, Level.Info);
    this.dependency.logToTerminal(
      `:: :: :: :: Input: ${totalInputCount}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: :: Packed Input: ${packedInputCount}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: :: Skipped: ${totalSkippedCount}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: :: Packed Output: ${totalOutputCount}`,
      Level.Info
    );
    const reducedFiles =
      totalInputCount - (totalOutputCount + totalSkippedCount);
    this.dependency.logToTerminal(
      `:: :: :: :: Reduced: ${reducedFiles} (${(
        (reducedFiles / totalInputCount) *
        100
      ).toFixed(2)}%)`,
      Level.Info
    );
    this.dependency.logToTerminal(`:: :: :: Areas:`, Level.Info);
    this.dependency.logToTerminal(
      `:: :: :: :: Input: ${totalInputSize}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: :: Packed Input: ${packedInputSize}`,
      Level.Info
    );
    const skippedSize = totalInputSize - packedInputSize;
    this.dependency.logToTerminal(
      `:: :: :: :: Skipped: ${totalInputSize - packedInputSize}`,
      Level.Info
    );
    this.dependency.logToTerminal(
      `:: :: :: :: Packed Output: ${totalOutputSize}`,
      Level.Info
    );
    const reducedSize = totalInputSize - (totalOutputSize + skippedSize);
    this.dependency.logToTerminal(
      `:: :: :: :: Reduced: ${reducedSize} (${(
        (reducedSize / totalInputSize) *
        100
      ).toFixed(2)}%)`,
      Level.Info
    );
    if (failedImageGenerationTasks.length) {
      this.dependency.logToTerminal(
        `:: :: :: Failed Tasks: ${failedImageGenerationTasks.length}`,
        Level.Error
      );
    }

    this.reportFailedTaskToConsole(failedImageGenerationTasks);
    // #endregion

    return resources as PostProcessedResourceItemForUpload[];
  }

  private reportFailedTaskToConsole(tasks: PromiseSettledResult<unknown>[]) {
    for (let i = 0; i < tasks.length; i += 1) {
      const task = tasks[i];

      if (task.status !== 'rejected') {
        continue;
      }

      this.dependency.logToTerminal(
        `:: :: :: [Task ${i}] ${task.reason}`,
        Level.Error
      );

      if (task.reason instanceof Error) {
        console.error(':: Failed task');
        console.error(':: :: Stack');
        console.error(task.reason.stack);
        console.error(':: :: End');
      }
    }
  }

  beforeFileImported(resources: IPostProcessedResourceFileForImport[]) {
    return resources;
  }

  async afterGroupCreated(
    files: (IResourceFile | IPostProcessedResourceFileForImport)[],
    newGroup: IResourceGroup
  ) {
    if (!newGroup.tags.includes(frameSequenceGroupResourceTag.id)) {
      return null;
    }

    const pointerFileId = nanoid();

    const parseResult = files.map((x) => {
      const regex = /.*?(\d+)\D*$/;
      const extractedNumber = regex.exec(x.label)?.[1];

      return {
        id: Number.parseInt(extractedNumber ?? '', 10),
        file: x,
      };
    });

    const sortedFiles = parseResult.some((x) => Number.isNaN(x.id))
      ? files.sort((x, y) => x.label.localeCompare(y.label))
      : parseResult.sort((x, y) => x.id - y.id).map((x) => x.file);

    sortedFiles.forEach((x, id) => {
      x.extensionConfigurations[`${AtlasResourceProcessor.id}~~frame`] =
        id.toString();
      x.extensionConfigurations[`${AtlasResourceProcessor.id}~~enabled`] =
        'yes';
      x.managedBy = pointerFileId;
      x.tags = [...new Set([...x.tags, imageCategoryTag.id])];
      this.dependency.updateResourceDefinition(x);
    });

    const emptyFile = createCanvas(1, 1);
    const context = emptyFile.getContext('2d');
    context.fillRect(0, 0, 1, 1);
    const fileBuffer = emptyFile.encodeSync('png');
    const md5 = await this.dependency.md5Hash(fileBuffer);
    const xxHash = await this.dependency.xxHash(fileBuffer);

    const pointerFile: IPostProcessedResourceFileForImport = {
      type: 'file',
      id: pointerFileId,
      label: `Recative Frame Sequence Pointer ${pointerFileId}`,
      episodeIds: [],
      mimeType: 'image/png',
      url: {},
      managedBy: null,
      originalHash: xxHash,
      convertedHash: {
        md5,
        xxHash,
      },
      cacheToHardDisk: false,
      preloadLevel: PreloadLevel.None,
      preloadTriggers: [],
      duration: null,
      removed: false,
      removedTime: -1,
      resourceGroupId: newGroup.id,
      tags: ['custom:frame-sequence-pointer!'],
      importTime: Date.now(),
      extensionConfigurations: {
        [`${AtlasResourceProcessor.id}~~frames`]: sortedFiles
          .map((x) => x.id)
          .join(','),
      },
      postProcessedFile: fileBuffer,
      postProcessedThumbnail: null,
    };

    newGroup.files.push(pointerFile.id);

    files.push(pointerFile);

    return {
      files,
      group: newGroup,
    };
  }

  beforePublishApplicationBundle(
    resources: (PostProcessedResourceItemForUpload | IResourceItem)[],
    profile: string
  ) {
    const atlasDefinitions = resources.filter(
      (x) => x.type === 'file' && x.tags.includes('custom:merged-atlas!')
    );

    console.log(`:: [Atlas] Found ${atlasDefinitions.length} atlas images`);

    for (let i = 0; i < atlasDefinitions.length; i += 1) {
      const atlasDefinition = atlasDefinitions[i];

      if (atlasDefinition.type !== 'file') {
        throw new TypeError(
          `Expected resource file, got ${atlasDefinition.type}`
        );
      }

      const includes =
        atlasDefinition.extensionConfigurations[
          `${AtlasResourceProcessor.id}~~includes`
        ];

      if (!includes) {
        throw new TypeError(
          `Atlas image includes nothing, this is not allowed`
        );
      }

      const dict = JSON.parse(
        atlasDefinition.extensionConfigurations[
          `${AtlasResourceProcessor.id}~~dict`
        ]
      );

      delete atlasDefinition.extensionConfigurations[
        `${AtlasResourceProcessor.id}~~dict`
      ];

      if (!dict) {
        throw new TypeError(`Atlas image has no dict, this is not allowed`);
      }

      if (typeof dict !== 'object' || dict === null) {
        throw new TypeError(
          `Atlas image dict is not an object, this is not allowed`
        );
      }

      const definedIds = new Set(includes.split(','));

      const includedFiles = resources.filter(
        (x) => definedIds.has(x.id) && x.type === 'file'
      );

      const includedIds = new Set(includedFiles.map((x) => x.id));

      if (includedIds.size !== definedIds.size) {
        if (profile === 'apPackLivePreview') {
          continue;
        }

        const missingFiles = [...definedIds].filter(
          (x) => !includedFiles.some((y) => y.id === x)
        );

        const missingIds = missingFiles.map((x) => x);
        console.log('-->', missingFiles);

        throw new TypeError(
          `Some included files are missing, this is a bug. Expected resource count: ${
            definedIds.size
          }, actually existed: ${includedIds.size} / ${
            resources.length
          }, Missing file: ${missingIds.join(`, `)}`
        );
      }

      for (let j = 0; j < includedFiles.length; j += 1) {
        const includedFile = includedFiles[j];
        const currentTask = dict[includedFile.id];

        if (!currentTask) {
          throw new TypeError(
            `Atlas image dict is missing a task for file ${includedFile.id}`
          );
        }

        if (
          typeof currentTask.x !== 'number' ||
          typeof currentTask.y !== 'number' ||
          typeof currentTask.w !== 'number' ||
          typeof currentTask.h !== 'number' ||
          typeof currentTask.flipped !== 'boolean'
        ) {
          throw new TypeError(
            `Atlas image dict task for file ${includedFile.id} is not valid`
          );
        }

        if (includedFile.type !== 'file') {
          throw new TypeError(
            `Expected resource file, got ${includedFile.type}`
          );
        }

        includedFile.url[
          REDIRECT_URL_EXTENSION_ID
        ] = `redirect://${atlasDefinition.id}#atlas`;

        includedFile.extensionConfigurations[
          `${AtlasResourceProcessor.id}~~x`
        ] = (currentTask.x + ATLAS_PADDING).toString();
        includedFile.extensionConfigurations[
          `${AtlasResourceProcessor.id}~~y`
        ] = (currentTask.y + ATLAS_PADDING).toString();
        includedFile.extensionConfigurations[
          `${AtlasResourceProcessor.id}~~w`
        ] = (currentTask.w - 2 * ATLAS_PADDING).toString();
        includedFile.extensionConfigurations[
          `${AtlasResourceProcessor.id}~~h`
        ] = (currentTask.h - 2 * ATLAS_PADDING).toString();
        includedFile.extensionConfigurations[
          `${AtlasResourceProcessor.id}~~f`
        ] = currentTask.flipped.toString();
      }
    }

    return resources;
  }

  beforePreviewResourceMetadataDelivered<
    T extends
      | IResourceItemForClient
      | IDetailedResourceItemForClient
      | IPostProcessedResourceFileForUpload
  >(resources: T[]) {
    resources.forEach((resource) => {
      if (
        resource.type === 'file' &&
        REDIRECT_URL_EXTENSION_ID in resource.url &&
        `${AtlasResourceProcessor.id}~~tw` in resource.extensionConfigurations
      ) {
        const redirectTo = resource.extensionConfigurations[
          REDIRECT_URL_EXTENSION_ID
        ].replace('redirect://', '').split('#')[0];

        if (!resources.find((x) => x.id === redirectTo && x.type === 'file')) {
          delete resource.url[REDIRECT_URL_EXTENSION_ID];
        }
      }
    });

    return null;
  }

  beforePreviewResourceBinaryDelivered() {
    return null;
  }
}
